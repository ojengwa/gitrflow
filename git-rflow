#!/usr/bin/env bash

#  https://github.com/thewoolleyman/gitrflow
#  Copyright (c) 2014 Chad Woolley - The MIT License

###
### Bash setup
###

# http://www.gnu.org/software/bash/manual/html_node/The-Set-Builtin.html

gitrflow_bash_xtrace=${GITRFLOW_BASH_XTRACE:-false}
if [[ ${gitrflow_bash_xtrace} == 'true' ]]; then
  export PS4="+(\${BASH_SOURCE}:\${LINENO}): \${FUNCNAME[0]:+\${FUNCNAME[0]}(): }"
  set -o xtrace
fi

gitrflow_bash_verbose=${GITRFLOW_BASH_VERBOSE:-false}
if [[ ${gitrflow_bash_verbose} == 'true' ]]; then
  set -o verbose
fi

set -o errexit # AKA -e - exit immediately on errors (http://mywiki.wooledge.org/BashFAQ/105)
set -o errtrace # AKA -E - any trap on ERR is inherited by subshell
set -o noclobber # AKA -C - disallow '>' to overwrite file (see http://mywiki.wooledge.org/NoClobber)
set -o nounset # AKA -u - guard against unused variables (see http://mywiki.wooledge.org/BashFAQ/035)
set -o pipefail # fail when pipelines contain an error (see http://www.gnu.org/software/bash/manual/html_node/Pipelines.html)

_log_prefix="[gitrflow] ${BASH_SOURCE}:"

function onexit() {
  local exit_status=${1:-$?}
  if [[ ${exit_status} != 0 ]]; then
    _error_line="error trapped."
  else
    _error_line=''
  fi
  if [[ $(type -t onexit_hook) = 'function' ]]; then
    onexit_hook
  fi
  echo "$_log_prefix $_error_line Exiting $0 with exit status $exit_status"
  exit "${exit_status}"
}

function disable_error_checking() {
  trap - ERR
  set +o errexit
}

function enable_error_checking() {
  trap onexit ERR
  set -o errexit
}

trap onexit HUP INT QUIT TERM ERR

###
### Command Processing
###

function exec_git() {
  unset git_output # reset output from any previous git command
  git_output_no_trace='' # reset output from any previous git command

  git_command="${@}"

  git_output=$(${git_command} 2>&1)

  if [[ -n ${git_output} ]] ; then
    handle_git_trace
    if [[ ${print_git_output} == 'true' ]] ; then
      echo "${git_output}"
    fi
  fi
}

function handle_git_trace() {
  if [[ ${GIT_TRACE} == 1 ]] ; then # if GIT_TRACE was set...
    if echo "${git_output}" | grep -q -v '^trace: ' ; then # if nontrace output exists
      git_output_no_trace=$(echo "${git_output}" | grep -v '^trace: ') # assign it
    fi
    if [[ ${print_git_output} == 'false' ]] ; then
      echo "${git_output}" | grep '^trace: ' # print GIT_TRACE output if other output is suppresed
    fi
  else
    git_output_no_trace=${git_output} # assign if GIT_TRACE was false
  fi
}

function run_branch_command() {
  # declare variables with local scope to this function and all subfunctions
  declare git_command
  declare git_output
  declare git_output_no_trace

  fail_unless_repo_clean
  fail_if_unpushed_changes

  case ${branch_type} in
    feature)
      case ${branch_command} in
        start)
          feature_start
          ;;
      esac
      ;;
  esac
}

function fail_unless_repo_clean() {
  exec_git 'git status --porcelain'
  if [[ -n ${git_output_no_trace} ]] ; then
    print_error_and_exit 'ERROR: Local repo is not clean. Please fix and retry.'
  fi
}

function fail_if_unpushed_changes() {
  exec_git 'git status --porcelain --branch'

  if [[ "${git_output}" == *'[gone]'* ]] ; then
    print_error_and_exit 'ERROR: Local repo is "gone". Please fix and retry.'
  fi

  if [[ ${git_output} =~ \[(ahead|behind) ]] ; then
    print_error_and_exit 'ERROR: Local repo has unpushed changes. Please fix and retry.'
  fi
}

function feature_start() {
  exec_git "git checkout -b ${branch_name}"

  if [[ (${print_git_output} == 'true' || ${GIT_TRACE} == 1) && -n ${git_output} ]] ; then
    printf "\n"
  fi
  printf "Summary of actions:\n"
  printf "%s A new branch '%s' was created, based on 'master'\n" '-' "${branch_name}"
  printf "%s You are now on branch '%s'\n\n" '-' "${branch_name}"
  printf "Now, start committing on your feature. When done, use:\n\n" '-' "${branch_name}"
  printf "     git flow feature finish %s\n" "${branch_name}"
}

###
### Option handling
###

function print_version() {
  echo 'git-rflow, version 0.0.1'
}

function print_usage_and_exit() {
  printf "Usage: gitrflow [options] <branch type> <command> [command options]\n\n"
  printf "Branch Types:\n"
  printf "    feature\n"
  printf "\n"
  printf "'feature' branch type commands and options:\n"
  printf "    feature start <branch_name>\n"
  printf "\n"
  printf "Options:\n"
  printf "    -h, --help\t\tDisplay this [h]elp\n"
  printf "    -o, --print-git-output\t\tDisplay [o]utput from git commands\n"
  printf "    -t, --trace\t\tEnable the GIT_TRACE environment variable\n"
  printf "    -V, --version\tDisplay the program [v]ersion\n"
  printf "    --\t\t\tIgnore all following options\n"
  printf "\nSee https://github.com/thewoolleyman/gitrflow for more information."
  exit 1
}

function print_error_and_exit() {
  echo "${1}" >&2
  printf "'git rflow --help' for usage.\n"
  exit 1
}

function parse_options() {
  set +o nounset

  # see http://stackoverflow.com/a/13864829/25192
  if [[ -z "${1+x}" ]] ; then
    print_usage_and_exit
  fi

  if [[ "${1}" == '--' ]] ; then
    print_usage_and_exit
  fi

  declare print_git_output='false'
  export GIT_TRACE='false'

  # from http://mywiki.wooledge.org/BashFAQ/035
  while :; do
    case ${1} in
      feature) # Takes an option arguments, ensuring they have been specified.
        declare branch_type=${1}
        if [[ "${2}" ]]; then
          declare branch_command=$2
          if [[ "${3}" ]]; then
            declare branch_name=$3
            shift 3
            continue
          else
            print_error_and_exit 'ERROR: The feature branch name is required.'
          fi
        else
          print_error_and_exit 'ERROR: The feature branch command is required.'
        fi
        ;;
      -h|--help)
        print_usage_and_exit
        ;;
      -o|--print-git-output)
        print_git_output='true'
        ;;
      -t|--trace)
        export GIT_TRACE=1
        ;;
      -V|--version)
        print_version
        exit 0
        ;;
      --) # ignore all following options
        shift
        break
        ;;
      *)
        # see http://stackoverflow.com/a/13864829/25192
        if [[ -z "${1+x}" ]] ; then
          break
        else
          print_error_and_exit "ERROR: Unrecognized parameter '${1}'"
        fi
    esac

    shift
  done

  set -o nounset

  run_branch_command
}

function invoke() {
  set +o nounset
  parse_options "${@}"
  set -o nounset
}

###
### invoke script
###

set +o nounset
invoke "${@}"
set -o nounset
